# Jest - Test code Rules

**Ref**

* [Mock Functions](https://jestjs.io/docs/mock-functions)

## Rules

* 한 번 작성된 테스트 코드는 영원히 유지보수 해야 한다.
  *  그러므로 clean code 작성을 하자
* 내부 구현 사항을 테스트 X
  * 사용자 입장에서 코드를 테스트해야지, 내부 동작 원리나 모듈 등을 테스트 하면 안 된다.
* 테스트 코드에서 반복되는 부분은 재사용성을 높이기 위해 유틸리티 함수를 작성한다.
* 테스트 코드가 배포가 될 때 포함되지 않도록 배포용 코드와 철저히 분리
* 테스트코드를 통한 문서화

## Structure of Test

<img src="https://user-images.githubusercontent.com/92770273/146503190-275b9e51-fdd9-474d-9937-fd4da8db197c.png" alt="image" style="zoom:40%;" />

1. Before
   1. beforeEach : 각각의 테스트가 시작하기 전에 실행
   2. beforeAll : 모든 테스트가 시작하기 전에 딱 한 번만 실행
2. Test
   1. 준비(Arrange-Given)
      * 준비 과정을 반복해서 사용한다면 재사용할 수 있도록 유틸리티 함수를 작성
   2. 실행(Act-When)
      * 의도적으로 실패를 해봐서 expect에 다른 값을 넣는다던지 이 테스트가 실패할 수 있도록 만든 다음에 실패했을 때 실패하지 않도록 하기 위해서 어떻게 코드를 수정하면 되는지 꼭 확인
   3. 검증(Assert-Then)
3. After
   1. afterEach : 각각의 테스트가 수행된 후에 실행
   2. beforeAll : 모든 테스트가 수행된 다음에 마무리로 한 번만 실행

## FIRST Rule

* F(Fast) : 느린 것에 대한 의존성 낮추기. 테스트가 빠르게 수행이 되어야 우리 프로젝트에서 백 개나 천 개의 테스트를 가지고 있더라도 빈번히 테스트를 수행해서 우리 코드에 문제가 없는지 검증할 수 있다.
  * 테스트하고자 하는 코드에서 파일, DB, network를 사용한다면 이것들은 테스트 코드를 느리게 만들 수 있고 이러한 것들에 의존하게 되니깐 테스트 코드도 불안정해진다. 이것을 해결하기 위해 mock이나 stub을 사용할 수 있다. 
* I(Isolated) : 고립적으로(독립적으로) 테스트 코드를 만들라. 최소한의 유닛으로 검증하기. 즉 하나의 테스트에서 너무 많은 것을 테스트하지 말자.
* R(Repeatable) : 반복이 가능하도록 만들어라. 이 뜻은 테스트 코드를 실행할 때마다 동일한 결과를 유지해야 한다. 그러기 위해서는 테스트 코드를 환경에 영향을 받지 않도록 작성해야 한다.
* S(Self-Validating) : 스스로 결과를 검증하기
  * CI/CD 파이프라인을 구성해서 새롭게 추가된 테스트 코드가 기존의 테스트 코드에 영향을 주는지 확인하자.
* T(Timely) : 시기적절하게 테스트 코드 작성. 사용자에게 배포되기 이전에 테스트 코드를 작성하자.

## Test Range

### Right-BICEP

* B(Boundary conditions) : 모든 코너 케이스에 대해 테스트를 하기
  * 잘못된 포맷의 인풋, null, 특수문자, 잘못된 이메일, 작은 숫자, 큰 숫자, 중복, 순서가 맞지 않음 등을 모두 테스트하라.
* I(Inverse relationship) : 역관계를 적용해서 결과 값을 확인
  * 일관성을 유지(덧셈 => 뺄셈, 추가 => 제거)
  * `5+5=10`을 테스트 했다면 반대로 `10-5=5`도 테스트가 성공해야 한다.
* C(Cross-check) : 다른 수단을 이용해서 결과 값이 맞는지 확인
  * `추가 된 과일 == 전체 과일 - 예전의 과일 갯수`로 체크할 수 있음
  * `A 알고리즘 == B 알고리즘`을 이용해서 특정 알고리즘이 정확하게 동작하는지 확인 가능
* E(Error conditions) : 불행한 경로에 대해 우아하게 처리 하는가?
  * 네트워크 에러, 메모리 부족, DB 중지 등 모든 에러 케이스에 대해서 테스트가 통과하는지 확인
* P(Performance characteristics) : 성능 확인은 테스트를 통해 정확한 수치로 확인. 성능 개선의 척도와 확인도 **데이터**를 통해 확인하자.

## Test Conditions

### CORRECT

* C(conformance) : 특정 포맷을 준수. 전화번호, 이메일, 아이디, 파일 확장자 등... 특정한 포맷을 따라야 하는 경우라면 인풋이 포맷에 적합하거나 맞지 않을 때 우리의 코드가 어떠한 방식으로 동작하는지 예상하는 각각의 테스트 코드를 작성해야 한다.
* O(Ordering) : 순서 조건 확인하기. 순서대로 값이 들어오지 않을 때 우리의 코드가 어떻게 반응할 것인지 예상하는 것들을 테스트 코드로 나타내야 한다.
* R(Range) : 숫자의 범위. 제한된 범위를 벗어났을 때 우리의 코드가 어떻게 동작하는지 예상하는 테스트 코드를 작성
* R(Reference) : 외부 의존성 유무, 특정한 조건의 유무를 테스트 해야 한다.
  * 예를 들어서, "~일 때, ~가 되어 있을 때, 어떤 특정한 상황/상태일때 이런 동작을 한다."라는 가정하는 코드가 있다. "특정한 B 함수를 호출할 때 A 함수를 먼저 호출해서 특정한 상태가 되었을 때 B라는 함수를 호출한다"라는 가정 상황이 있다. 그래서 테스트 코드에서도 B 함수를 호출할 때 A 함수가 호출되어 있지 않다면 어떻게 될 것인지 테스트 코드를 짜야 한다.
* E(Existence) : 값이 존재 하지 않을 때 어떻게 동작 할 것인지. 우리가 예상하는 값이 null, undefined, "", 0일 경우 우리의 코드가 어떻게 동작하는지도 확인하고 테스트 하자.
* C(Cardinality) : 0-1-N 법칙에 따라 검증. 하나도 없을 때, 하나만 있을 때, 여러 개가 있을 때.
  * 특정한 목록에 대해 테스트를 할 때 목록이 **하나도 없을 때, 하나만 있을 때, 여러 개가 있을 때** 우리의 코드가 어떻게 동작하는지 테스트 하는 코드를 짜라
* T(Time) : 상대, 절대, 동시의 일들이 '이런식 혹은 저런식으로 동작했을 때' 코드가 어떻게 반응하는지 검증하라.
  * 예를 들어, 순서가 맞지 않은 경우, 특정한 시간을 너무 지나치게 소비했을 때, 나라마다 지역 시간이 다른데 이 때는 코드가 어떻게 동작하는지 검사하라.
