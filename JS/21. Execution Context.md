# Execution Context

## Execution Context

- 함수가 실행되는 영역, 묶음
- 함수 코드를 실행하고 실행 결과를 저장
- 스펙상의 사양
- 실행 컨텍스트 스펙

```js
function music(title){
  var musicTitle = title;
}
music("음악");
```

- music("음악")으로 함수를 호출하면
  - 엔진은 실행 콘텍스트를 생성하고
  - 실행 콘텍스트 안으로 이동한다.
- 실행 콘텍스트 실행 단계
  - 준비 단계, 초기화 단계, 코드 실행 단계
- Execution Context 생성 시점
  - 실행 가능한 코드를 만났을 때
  - 실행 가능한 코드 : 함수 코드, 클로벌 코드, eval 코드
- 코드 유형을 분리한 이유 : 실행 컨텍스트에서 처리 방법과 실행 환경이 다르기 때문이다.
  - 함수 코드 : 렉시컬 환경
  - 글로벌 코드 : 글로벌 환경
  - eval 코드 : 동적 환경



## 실행 컨텍스트 상태 컴포넌트

```js
실행 컨텍스트(EC) : {
  렉시컬 환경 컴포넌트(LEC) : { },
  
  변수 환경 컴포넌트(VEC) : { },
    
  this 바인딩 컴포넌트(TBC) : { }
}
```

- 실행 컨텍스트 상태를 위한 오브젝트
  - 실행 컨텍스트 안에 생성
- 상태 컴포넌트 유형
  - 렉시컬 환경 컴포넌트(LEC) : Lexical Environment Component
  - 변수 환경 컴포넌트(VEC) : Variable Environment Component
  - this 바인딩 컴포넌트(TBC) : This Binding Component



## 렉시컬 환경 컴포넌트, 렉시컬 환경 컴포넌트 구성/설정, 외부 렉시컬 환경 참조, 변수 환경 컴포넌트

### 렉시컬 환경 컴포넌트

- 함수와 변수의 식별자 해결을 위한 환경 설정
- 함수 초기화 단계에서 해석한
  - 함수와 변수를 { name : value } 형태로 저장
    - 함수 선언문은 { name : Function Object }
    - 변수는 { name : undefined }
    - 로 저장된다.
  - 이름으로 함수와 변수를 검색할 수 있게 됨
- 함수 밖의 함수와 변수 참조 환경 설정
  - 함수 밖의 함수와 변수를 사용할 수 있게 됨

### 렉시컬 환경 컴포넌트 구성

```js
실행 컨텍스트(EC) : {
  렉시컬 환경 컴포넌트(LEC) : {
    환경 레코드(ER) : {
      point : 100
    },
    외부 렉시컬 환경 참조(OLER) : {
      title : "책",
      getTitle : function(){}
    }
  },
}
```

- 렉시컬 환경 컴포넌트 생성
  - function, with, try-catch에서 생성
- 컴포넌트 구성
  - 환경 레코드
    - ER : Environment Record
  - 외부 렉시컬 환경 참조
    - OLER : Outer Lexical Environment Reference

### 렉시컬 환경 컴포넌트 설정

- 환경 레코드에 함수 안의 함수와 변수를 기록한다.
- 외부 렉시컬 환경 참조에 function 오브젝트의 [[Scope]]를 설정
- 따라서 함수 안과 밖의 함수와 변수를 사용할 수 있게 됨

### 외부 렉시컬 환경 참조

- 스코프와 실행중인 함수가 Context 형태이므로 스코프의 변수와 함수를 별도의 처리 없이 즉시 사용할 수 있음
- 실행 컨텍스트에서 함수 안과 밖의 함수, 변수를 사용할 수 있으므로 함수와 변수를 찾기 위해 실행 컨텍스트를 벗어 나지 않아도 된다.

### 변수 환경 컴포넌트

- 실행 컨텍스트 초기화 단계에서 변수 환경 컴포넌트를 렉시컬 환경 컴포넌트와 같게 설정
- 이렇게 하는 이유는?
  - 초깃값을 복원할 때 사용하기 위한 것
- 함수 코드가 실행되면
  - 실행 결과를 렉시컬 환경 컴포넌트에 설정
  - 초깃값이 변하게 되므로 이를 유지하기 위한 것
- 변수에 값이 할당되면 렉시컬 환경 컴포넌트의 값이 변경된다. 이 때 다시 초깃값으로 돌아가고 싶을 때, 초기 렉시컬 환경 컴포넌트로 초기화 시켜준 변수 환경 컴포넌트 값을 덮어씌워준다.
- with 문에서 사용된다.

### 실행 컨텍스트 실행 과정1

```js
var base = 200;
function getPoint(bonus){
  var point = 100;
  return point + base + bonus;
};
console.log(getPoint(70));
```

1. getPoint 오브젝트의 [[Scope]]에 글로벌 오브젝트 설정
2. 마지막 줄에서 getPoint() 함수 호출하면
3. 엔진은 실행 컨텍스트를 생성하고 실행 컨텍스트 안으로 이동한다.

------------------------------

준비단계

------------------------------

4. 컴포넌트를 생성하여 실행 컨텍스트에 첨부

   - 렉시컬 환경 컴포넌트

   - 변수 환경 컴포넌트

   - this 바인딩 컴포넌트

5. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부

   - 함수 안의 함수, 변수를 바인딩한다.

   ```js
   실행 컨텍스트(EC) : {
     렉시컬 환경 컴포넌트(LEC) : {
       환경 레코드(ER) : {},
       변수 환경 컴포넌트(VEC) : {},
       this 바인딩 컴포넌트(TBC) : {}
     },
   }
   ```

6. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부하고 function 오브젝트의 [[Scope]]를 설정

   ```js
   실행 컨텍스트(EC) : {
     렉시컬 환경 컴포넌트(LEC) : {
       환경 레코드(ER) : {},
       외부 렉시컬 환경 참조(OLER) : {
         base : 200
       },
       변수 환경 컴포넌트(VEC) : {},
       this 바인딩 컴포넌트(TBC) : {}
     },
   }
   ```

---

초기화 단계

---

7. 호출한 함수의 파라미터 값을

   - 호출된 함수의 파라미터 이름에 매핑
   - 환경 레코드에 작성

8. 함수 선언문을 function 오브젝트로 생성

9. 함수 표현식과 변수에 초깃값 설정

10. 여기까지는 외부에 실행 상태를 제공하지 않는다.

    ```js
    실행 컨텍스트(EC) : {
      렉시컬 환경 컴포넌트(LEC) = {
        환경 레코드(ER) : {
          bonus : 70,
          point : undefined
        },
        외부 렉시컬 환경 참조(OLER) : {
          base : 200
        },
        변수 환경 컴포넌트(VEC) : {},
        this 바인딩 컴포넌트(TBC) : {}
      },
    }
    ```

---

실행 단계

---

11. 함수 안의 코드를 실행한다.
    - var point = 100;
12. 실행 컨텍스트 안에서 관련된 함수와 변수를 사용할 수 있다.

### 실행 컨텍스트 실행 과정2

```js
function book(){
  function get(){
    return point;
  }
  var point = 123;
  return get();
}
console.log(book()); // 123
```

1. function 키워드를 만나 book이라는 function 오브젝트를 생성하고, 오브젝트의 [[Scope]]에 글로벌 오브젝트 설정
2. 마지막 줄에서 book() 함수를 호출하면
3. 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동 

---

==준비 단계 (실행 콘텍스트에서 실행할 수 있는 환경 구축)==

---

4. 컴포넌트를 생성하여 실행 콘텍스트에 첨부
   - 렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, this 바인딩 컴포넌트
5. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부
6. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부하고 
   - book이라는 function 오브젝트의 [[Scope]]를 설정(참조)

---

==초기화 단계==

---

7. 호출한 함수의 파라미터 값이 있다면, 호출된 함수의 파라미터 값에 매핑하여 환경 레코드에 작성하나 파라미터 없음
8. function 키워드를 만나 get이라는 function 오브젝트를 만들고 [[Scope]]로 book 오브젝트를 설정 
9. point라는 변수에 undefined를 할당 
10. 여기까지는 외부에 실행 상태를 제공하지 않음 

```js
실행 컨텍스트(EC) : {
  렉시컬 환경 컴포넌트(LEC) = {
    환경 레코드(ER) : {
      get : function 오브젝트
      point : undefined
    },
    외부 렉시컬 환경 참조(OLER) : {},
    변수 환경 컴포넌트(VEC) : {},
    this 바인딩 컴포넌트(TBC) : {}
  },
}
```

---

==실행 단계==

---

11. book 함수 안의 코드를 실행
12. point 변수에 123을 할당
13. get() 함수를 호출하면 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동 

**get()함수의 실행 콘텍스트**

---

==준비 단계==

---

14. 컴포넌트를 생성하여 실행 콘텍스트에 첨부
    - 렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, this 바인딩 컴포넌트
15. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부
16. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부하고 
    - get이라는 function 오브젝트의 [[Scope]]를 설정

```js
실행 컨텍스트(EC) : {
  렉시컬 환경 컴포넌트(LEC) = {
    환경 레코드(ER) : {},
    외부 렉시컬 환경 참조(OLER) : {
      point : 123
    },
    변수 환경 컴포넌트(VEC) : {},
    this 바인딩 컴포넌트(TBC) : {}
  },
}
```

---

==초기화 단계==

---

17. 파라미터가 없고 function 키워드나 변수가 없음

---

==실행 단계==

---

18. return point를 만나고, point라는 식별자를 외부 렉시컬 환경 참조에서 찾아 123을 반환 
19. get()함수의 reutrn 값이 book()함수의 return 값이므로 콘솔창에 123을 출력 



## 환경 레코드, 환경 레코드 구성, 글로벌 환경

### 환경 레코드 구성

- 환경 레코드를 구분하는 이유
  - 기록 대상에 따라 다르기 때문
- 선언적 환경 레코드
  - DER : Declarative Environment Record
  - function, 변수, catch 문에서 사용
  - 앞 절에서 환경 레코드에 설정한다고 했는데 설명을 위한 것으로 실제로 여기에 설정
- 오브젝트 환경 레코드
  - OER : Object Environment Record
  - 글로벌 함수와 변수, with 문에서 사용
  - 정적이 아니라 동적이기 때문

### 글로벌 환경

- Global Environment
  - 글로벌 오브젝트에서 사용
  - 렉시컬 환경 컴포넌트와 형태 같음
- 동적으로 함수와 변수 바인딩
  - 함수에서 var 키워드를 사용하지 않고 변수를 선언하면 글로벌 오브젝트에 설정되기 때문이다. 이런 이유로 오브젝트 환경 레코드 사용
- 외부 렉시컬 환경 참조 값은 null



## this 바인딩 컴포넌트

- 목적
  - this로, 함수를 호출한 오브젝트의 프로퍼티에 엑세스
  - 예 : this.propertyName
- 엑세스 메커니즘
  - obj.book() 형태에서
  - this로 obj를 참조할 수 있도록
  - this 바인딩 컴포넌트에 obj 참조를 설정
- obj의 프로퍼티가 변경되면 동적으로 참조
  - 설정이 아닌 참조이기 때문이다.

### this 바인딩 컴포넌트 설정 과정

```js
var obj = { point : 100 };
obj.getPoint = function(){
  return this.point;
};
obj.getPoint();
```

```js
실행 컨텍스트 : {
  렉시컬 환경 컴포넌트 = {
    환경 레코드(ER) : {
      선언적 환경 레코드(DER) : {},
      오브젝트 환경 레코드(OER) : {}
    },
    외부 렉시컬 환경 참조 : {}
  },
  변수 환경 컴포넌트 : {},
  this 바인딩 컴포넌트(TBC) : {
    point : 100,
    getPoint: function(){}
  }
}
```

---

준비 단계

---

1. 마지막 줄에서 obj.getPoint() 함수 호출
2. 실행 컨텍스트 생성
3. 3개의 컴포넌트 생성
   - 렉시컬/변수 환경 컴포넌트, this 바인딩 컴포넌트
4. this 바인딩 컴포넌트에
   - getPoint()에서 this로 obj의 프로퍼티를 사용할 수 있도록 바인딩

------------------------------

초기화 단계

------------------------------

5. 파라미터, 함수 선언문, 변수 선언 없음

---

실행 단계

---

6. return this.point; 실행
7. this 바인딩 컴포넌트에서 point 검색
   - getPoint() 함수를 호출한 오브젝트가 this 바인딩 컴포넌트에 설정(참조)된 상태
8. this 바인딩 컴포넌트에
   - point 프로퍼티가 있으므로 100을 반환

---

추가 설명

---

9. obj.getPoint()에서 obj의 프로퍼티가 this 바인딩 컴포넌트에 바인딩되도록 의도적으로 설계해야 한다.



## 호출 스택(Call stack)

```js
function one(){
  two();
  console.log(1);
};
function two(){
  three();
  console.log(2);
};
function three(){
  console.log(3);
};
one();

/*
	실행 결과
	3
	2
	1
*/
```

- call stack
  - 실행 컨텍스트의 논리적 구조
- First In Last Out 순서
  - 함수가 호출되면 스택의 가장 위에 실행 컨텍스트가 위치하게 된다.
  - 다시 함수 안에서 함수를 호출하면 호출된 함수의 실행 컨텍스트가 스택의 가장 위에 놓이게 된다.
  - 함수가 종료되면 스택에서 빠져 나옴(FILO 순서)
  - 이러한 스택 방식이 가능한 것은 JS엔진이 싱글 스레드이기 때문이다. 즉 하나의 스레드에서 작동하기 때문이다.
- 가장 아래는 글로벌 오브텍트의 함수가 위치.



## 파라미터 매핑, 함수 호출, 파라미터 값 매핑, 파라미터 이름에 값 매핑 방법

### 함수 호출

- 함수가 호출되면 3개의 파라미터 값을 실행 컨텍스트로 넘겨 준다.
  - 함수가 호출한 오브젝트
  - 함수 코드
  - 호출한 함수의 파라미터 값
- 함수를 호출한 오브젝트를 this 바인딩 컴포넌트에 설정하여 this로 참조
- 함수 코드
  - function 오브젝트의 [[Code]]에 설정되어 있음
- 호출한 함수의 파라미터 값
  - 호출된 함수의 Argument 오브젝트에 설정

### 파라미터 값 매핑

- 파라미터 값 매핑이란?
  - 호출한 함수에서 넘겨 준 파라미터 값을 호출된 함수의 파라미터 작성 순서에 맞추어 값을 매핑하는 것
- 엔진 처리 관점
  - 실행 컨텍스트로 넘겨 준 파라미터 값과
  - function 오브젝트의 [[FormalParameters]]에 작성된 이름에 값을 매핑하고 결과를 선언적 환경 레코드에 설정하는 것

### 파라미터 이름에 값 매핑 방법

```js
var obj = {};
obj.getTotal = function(one, two){
  return one + two;
}
console.log(obj.getTotal(11, 22, 77));
```

1. getTotal 오브젝트의 [[FormalParameters]]에서
   - 호출된 함수의 파라미터 이름을 구한다.
   - 설명 편의를 위해 name이라고 한다.
   - name은 ["one", "two"] 형태다.
   - [[FormalParameters]]는 function 오브젝트를 생성할 때 설정한다.
2. name 배열을 하나씩 읽는다.
3. param에서 index 번째의 값을 구한다.
   - 인덱스에 값이 없으면 undefined 반환
4. name의 파라미터 이름과 3번에서 구한 값을 선언적 환경 레코드에 { one : 11, two : 22 } 형태로 설정한다.
   - 같은 이름이 있으면 값이 대체된다.
5. name을 전부 읽을 때까지 2번에서 4번까지 반복
